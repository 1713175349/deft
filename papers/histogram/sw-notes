run long simulations for all methods to make sure they mutually converge
 - for different temperatures

reference file instead of reference method for "answer"

add data comparing references
add best reference against which to compare standard runs

error vs. temperature plot for U and CV
include temp of max error in error file
 - max error vs N plots (or tables)
 - use ratios of errors relative to the geometric mean of errors in one method

try iteration number end condition for comparison
 - implement option for time end condition

add option to specify energy range for WL
 - flatten weights outside the energy range (or somehow disallow),
     but set them to canonical after initialization
 - use this energy range for comparisons
optionally look for a minimum important energy to define the energy range



make sure we're not breaking wang_landau by not specifying a minimum energy



run optimized_ensemble, tmmc, and robustly_optimistic for each end condition
    for many small N


clean up optimized_ensemble
 - find df/dE by secant line in f(E)
   - secant line with 1/sqrt(e_hist[i]) up/down in f*e_hist[i]
   - average weights if we have an energy jump


IF we have a problem with picking bad minimum energies, consider requiring
  a minimum histogram count of exp(1/min_T) at the minimum energy


make iterations vs initialization quality plot

make wang_landau and tmmc dump weight aray and histogram periodically





run [vanilla_]wang_landau for 60, 80, 100, 150, 200
 - go from 100 to 200 by 20s?


after figuring out what to do with end conditions, run sims with large Ns and various min_Ts

