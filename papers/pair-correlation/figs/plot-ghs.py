#!/usr/bin/python
from __future__ import division
# We need the following two lines in order for matplotlib to work
# without access to an X server.
import matplotlib, sys, os.path, sympy, numpy
if len(sys.argv) < 2 or sys.argv[1] != "show":
  matplotlib.use('Agg')
from scipy.optimize import leastsq
from sympy import pi, exp
import pylab

# create variables to store latex / C++ code
latex_code = r"""% Code generated by plot-ghs.py
\documentclass{article}
\usepackage{breqn}
\begin{document}
"""
c_code = r"""// Code generated by plot-ghs.py
#include <math.h>
"""

# def to_latex(sym, exp):
#   global latex_code
#   latex_code += sympy.latex(sympy.Eq(sym, exp), mode='equation')
#   return exp

# define variables / constants
base = ['r', 'kappa_0', 'kappa_1', 'kappa_2', 'h_sigma']
# expressions is a list of tuples, where each tuple is the name of a variable followed by the
# expression it is equal two, in terms of lambda expressions of the dict v.
expressions = [
  ('g_HS', lambda: 1 + v['h_sigma']*exp(-v['kappa_0']*v['xi']) + v['a_1']*v['xi']*exp(-v['kappa_1']*v['xi']) + v['a_3']*v['xi']**2*exp(-v['kappa_2']*v['xi'])),
  ('a_3', lambda: (v['A'] - v['C']*v['a_1'])/v['B']), # sets integral
  ('A', lambda: (v['rhs']-1)/v['n'] - v['int_h0']),
  ('B', lambda: 8*pi*(12 + v['sigma']*v['kappa_2']*(6 + v['sigma']*v['kappa_2']))/v['kappa_2']**5),
  ('C', lambda: 4*pi*v['h_sigma']*(2 + v['sigma']*v['kappa_0']*(2 +v['sigma']*v['kappa_0']))/v['kappa_0']**3
   - 4*pi*v['sigma']**3/3),
  ('int_h0', lambda: 4*pi*v['h_sigma']*(2 + v['sigma']*v['kappa_0']*(2 + v['sigma']*v['kappa_0']))
   /v['kappa_0']**3 - 4*pi*v['sigma']**3/3),
  ('rhs', lambda: (1-v['eta'])**4/(1 + 4*v['eta'] + 4*v['eta']**2 - 4*v['eta']**3 + v['eta']**4)),
  ('n', lambda: 3/(4*pi)*v['eta']), # n is the number density
  ('a_1', lambda: v['h_sigma']*(v['kappa_0'] - 1 - v['h_sigma'])), # sets slope at g_sigma
  ('eta', lambda: eta_expr),
  ('xi', lambda: (v['r'] - v['sigma'])/v['R']),
  ('R', lambda: v['sigma']/2),
  ('sigma', lambda: sympy.S(2))
]
l = []
expr = []
for x in expressions:
  l.append(x[0])
  expr.append(x[1])

v = dict((elem, sympy.symbols(elem)) for elem in l+base)

h_sigma_expr = (1 - v['eta']/2)/(1 - v['eta'])**3 - 1
h_sigma_equation = sympy.Eq(v['h_sigma'], h_sigma_expr)
# this will return 3 expressions, 2 of which are complex
eta_expressions = sympy.solve(h_sigma_equation, v['eta'], minimal=True)

eta_expr = eta_expressions[0]

# get the real eta:
for i in xrange(len(eta_expressions)):
  # fixme: this is an incredibly hokey way of determining which expression is real,
  # and would fail if 'I' appeared anywhere in the expression as something other than
  # the imaginary i. None of the sympy checking if things are real seem to work on
  # expressions, so I'm not sure of a nice way to do this.
  if 'I' not in str(eta_expressions[i]):
    eta_expr = eta_expressions[i]
    break

for i in xrange(len(expr)):
  latex_code += '\\begin{dmath}\n' + sympy.latex(sympy.Eq(v[l[i]], expr[i]())) + '\n\\end{dmath}\n'

# the expression for h_sigma is not included in the above list,
# so let's manually throw it into the latex
latex_code += '\\begin{dmath}\n' + sympy.latex(sympy.Eq(v['h_sigma'], h_sigma_expr)) + '\n\\end{dmath}\n'

# this loop unwraps the onion, getting ghs in terms of only the 3 kappas, h_sigma, and r
for i in reversed(xrange(len(expr))):
  temp = v[l[i]]
  v[l[i]] = expr[i]()
  # v[l[i]] = sympy.simplify(expr[i]() this makes it take way too long
  latex_code += '\\begin{dmath}\n' + sympy.latex(sympy.Eq(temp, v[l[i]])) + '\n\\end{dmath}\n'


#################################################################################################


# now that wehave ghs defined, we want to do a best fit to find kappa_0, kappa_1, and kappa_2
sigma = 2
lam = sympy.utilities.lambdify(('kappa_0', 'kappa_1', 'kappa_2', 'eta', 'r'), expr[0]().subs('h_sigma', h_sigma_expr), 'numpy')

def evalg(x, eta, r):
  return lam(x[0], x[1], x[2], eta, r)

def read_ghs(base, ff):
  mcdatafilename = "%s-%4.2f.dat" % (base, ff)
  if (os.path.isfile(mcdatafilename) == False):
    print "File does not exist: ", mcdatafilename  ('xi', lambda: (v['r'] - v['sigma'])/v['R']),

    global able_to_read_file
    able_to_read_file = False
    return 0, 0

  mcdata = numpy.loadtxt(mcdatafilename)
  print 'Using', mcdatafilename, 'for filling fraction', ff
  r_mc = mcdata[:,0]
  n_mc = mcdata[:,1]
  ghs = n_mc/ff
  return r_mc, ghs

colors = ['r', 'g', 'b', 'c', 'm', 'k', 'y']
ff = numpy.array([.4, .3, .2, .1])

x = numpy.array([1.9, 1.4, 1.6])


# read data
able_to_read_file = True

ghs = [0]*len(ff)
eta = [0]*len(ff)

pylab.figure(1, figsize=(5,4))
pylab.axvline(x=sigma, color='k', linestyle=':')
pylab.axhline(y=1, color='k', linestyle=':')

for i in range(len(ff)):
    r_mc, ghs[i] = read_ghs("figs/gr", ff[i])
    if able_to_read_file == False:
        break
    pylab.figure(1)
    pylab.plot(r_mc, ghs[i], colors[i]+"-",label='$\eta = %.1f$'%ff[i])
    eta[i] = ff[i]
    r = r_mc

if able_to_read_file == False:
  pylab.plot(arange(0,10,1), [0]*10, 'k')
  suptitle('!!!!WARNING!!!!! There is data missing from this plot!', fontsize=25)
  pylab.savefig("figs/ghs-g2.pdf")
  pylab.savefig("figs/ghs-g-ghs2.pdf")
  exit(0)

# now do the least squares fit
def dist(x):
  # function with x[i] as constants to be determined
  R, ETA = pylab.meshgrid(r, eta)
  g = pylab.zeros_like(ETA)
  g = evalg(x, ETA, R)
  return pylab.reshape(g, len(eta)*len(r))

def dist2(x):
  return dist(x) - pylab.reshape(ghs, len(eta)*len(r))

ghsconcatenated = ghs[0]
for i in range(1,len(ff)):
  ghsconcatenated = pylab.concatenate((ghsconcatenated, ghs[i]))

etaconcatenated = [0]*len(r)*len(eta)
j = 0
while (j < len(eta)):
  i = 0
  while (i < len(r)):
    etaconcatenated[i + j*len(r)] = eta[j]
    i += 1
  j += 1

rconcatenated = [0]*len(r)*len(eta)
j = 0
while (j < len(eta)):
  i = 0
  while (i < len(r)):
    rconcatenated[i + j*len(r)] = r[i]
    i += 1
  j += 1

vals = pylab.zeros_like(x)

chi2 = sum(dist2(x)**2)
print "beginning least squares fit, chi^2 initial: %g" %chi2
vals, mesg = leastsq(dist2, x)
chi2 = sum(dist2(vals)**2)
print "original fit complete, chi^2: %.3f" % chi2

toprint = True
for i in range(len(x)):
  print "vals[%i]: %.3f\t x[%i]: %g" %(i, vals[i], i, x[i])

g = dist(vals)
gdifference = dist2(vals)

chisq = (gdifference**2).sum()
maxerr = abs(gdifference).max()
etamaxerr = 0
rmaxerr = 0
for i in xrange(len(gdifference)):
  if abs(gdifference[i]) == maxerr:
    etamaxerr = etaconcatenated[i]
    rmaxerr = rconcatenated[i]
K0 = vals[0]
K1 = vals[1]
K2 = vals[2]

# finish printing to latex and c++ with the constants
c_code += r"""
const double kappa_0 = %g;
const double kappa_1 = %g;
const double kappa_2 = %g;

inline double gsigma_to_eta(const double gs) {
  if (gs <= 1) return 0;
  const double h_sigma = gs - 1;
  return %s;
}


inline double radial_distribution(double gsigma, double r) {
  if (gsigma <= 1) return 1; // handle roundoff error okay
  if (r < %i) return 0;
  const double h_sigma = gsigma - 1;
  return %s;
}
""" %(K0, K1, K2, sympy.ccode(v['eta']), v['sigma'], sympy.ccode(v['g_HS']))

latex_code += r"""
\begin{dmath}
\kappa_0 = %g
\end{dmath}
\begin{dmath}
\kappa_1 = %g
\end{dmath}
\begin{dmath}
\kappa_2 = %g
\end{dmath}
\end{document}
""" %(K0, K1, K2)

f = open('figs/ghs-analytics.tex', 'w')
f.write(latex_code)
f.close()

f = open('figs/ghs-analytics.h', 'w')
f.write(c_code)
f.close()

# now let's plot the fit
for i in range(len(ff)):
  pylab.figure(1)
  pylab.plot(r_mc, g[i*len(r):(i+1)*len(r)], colors[i]+'--')
  hsigma = (1 - 0.5*ff[i])/(1-ff[i])**3 - 1
  density = 4/3*pi*ff[i]
  rhs = (1-ff[i])**4/(1+4*ff[i]+4*ff[i]**2-4*ff[i]**3+ff[i]**4)/3
  #integral = hsigma*(1/a + x[0]*x[1]/())



  #print density, integral, rhs
  #print "ff: %.2f\t thing: %g" %(ff[i], 1 - rho*integral - rhs)
  pylab.figure(2)
  #plot(r_mc, gdifference[i*len(r):(i+1)*len(r)], colors[i]+'--')
  pylab.plot(r_mc, g[i*len(r):(i+1)*len(r)] - ghs[i], colors[i]+'-')
  # calculating integral:
  #mc:
  r_mc, ghs[i]
  integrand_mc = 4*pi*r_mc*r_mc*ghs[i]
  integrand_ours = 4*pi*r_mc*r_mc*g[i*len(r):(i+1)*len(r)]
  integral_mc = sum(integrand_mc)/len(integrand_mc)*(r_mc[2]-r_mc[1]) - 4/3*pi*sigma**3
  integral_ours = sum(integrand_ours)/len(integrand_ours)*(r_mc[2]-r_mc[1]) - 4/3*pi*sigma**3
  print("Int_mc: %6.3f, Int_ours: %6.3f, Diff: %6.3f" %(integral_mc, integral_ours, integral_ours-integral_mc))



  #plot(r_mc, numpy.abs(numpy.asarray(ghsconcatenated[i*len(r):(i+1)*len(r)]) - ghs[i]), color+'-')



pylab.figure(1)
pylab.xlim(0,6.5)
pylab.ylim(0., 3.5)
pylab.xlabel(r"$r/R$")
pylab.ylabel("$g(r)$")
pylab.legend(loc='best').get_frame().set_alpha(0.5)

pylab.tight_layout()
pylab.savefig("figs/ghs-g2.pdf")


pylab.figure(2)
pylab.xlim(2,6.5)
pylab.ylim(-.25, .25)
pylab.xlabel(r"$r/R$")
pylab.ylabel("|ghs - g|")
pylab.savefig("figs/ghs-g-ghs2.pdf")

pylab.axhline(y=0)
pylab.xlim(2,6.5)
pylab.legend(loc='best')
pylab.show()
